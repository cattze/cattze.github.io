<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="socat">
<meta property="og:url" content="http:socat.cc/page/2/index.html">
<meta property="og:site_name" content="socat">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="socat">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http:socat.cc/page/2/"/>





  <title>socat</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">socat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/12/16/react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/16/react/" itemprop="url">React组件生命周期（ES6）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-16T00:00:00+08:00">
                2016-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、组件的属性(props)和状态(state)<br>   属性：它是组件的不可变属性（组件自己不可以自己修改props），只可由其他组件调用它时在外部修改。是父组件与子组件通信的桥梁。<br>   状态：它是组件的内部状态属性，主要用来存储组件自身需要的数据。是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。组件中由系统定义了setState方法，每次调用setState时都会更新组件的状态，触发render方法重新渲染界面。<br>二、生命周期<br>   生命周期来说一般分为四个阶段，分别为：创建阶段、实例化阶段、运行(更新)阶段、销毁阶段。<br>   <img src="http://oo6ltjdyl.bkt.clouddn.com/2428275-f08403a3ea1b80f4.png" alt=""><br>   1､ 创建阶段：该阶段主要发生在创建组件类的时候，在这个阶段中会初始化组件的属性类型和默认属性。<br>      defaultProps：初始化一些默认的属性，通常会将固定的内容放在这个过程中进行初始化和赋值，一个控件可以利用this.props获取在这里初始化它的属性，<br>   2､ 实例化阶段：该阶段主要发生在组件类被调用(实例化)的时候。<br>      1) constructor(props)获取实例的初始状态：通过constructor(构造器)对状态进行初始化。<br>      <blockquote><pre><code><span>constructor(props) {</span><br>        <span>console.log(“获取实例的初始状态”);</span><br>        <span>super(props);</span><br>        <span>this.state = {</span><br>          <span>will: true</span><br>        <span>};</span><br>      <span>}</span></code></pre></blockquote><br>      2) componentWillMount()组件即将被渲染到页面：在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。这个函数在整个生命周期中只被调用一次。<br>      3) render()：组件在render中生成虚拟的DOM节点，即JSX，最后由React生成真实在的DOM节点。只能访问this.props和this.state，不应再访问其它信息，只有一个顶层组件，但是可以有其它子组件，不允许修改状态和DOM输出。<br>      4) compoentDidMount()组件被渲染到页面之后：render方法后，组件加载成功并被成功渲染出来以后所执行的hook函数，可以修改DOM。<br>   3､ 运行(更新)阶段：该阶段主要发生在用户操作之后，或者父组件有更新的时候，此时会根据用户的操作行为，进行相应的界面结构调整。<br>      1) componentWillReceiveProps(nextProps)组件快要接收到属性：当组件接收到新的props时，会触发该函数。通常可以调用setState()来完成对state的修改。<br>      2) shouldComponentUpdate(nextProps, nextState)组件是否需要更新：nextState 表示组件即将更新的状态值。这个函数的返回值决定是否需要更新组件，如果 true 表示需要更新，继续走后面的更新流程。否者，则不更新，直接进入等待状态。默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。<br>      3) componentWillUpdate(nextProps, nextState)组件即将被更新：返回true，就会开始准更新组件，并调用 componentWillUpdate()。在这个函数里面，你就不能使用 this.setState 来修改状态。这个函数调用之后，就会把 nextProps 和 nextState 分别设置到 this.props 和 this.state 中。紧接着这个函数，就会调用 render() 来更新界面了。<br>      4) render()：再确定需要更新组件时，调用render，根据diff算法，渲染界面，生成需要更新的虚拟DOM数据。<br>      5) componentDidUpdate()组件更新被渲染到页面：虚拟DOM同步到DOM中后，执行该方法，可以在这个方法中做DOM操作。除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。<br>      <blockquote><pre><code><span>componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。</span><br>    <span>区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用。</span><br>    <span>ps：绝对不要在componentWillUpdate和componentDidUpdate中调用this.setState方法，否则将导致无限循环调用。</span></code></pre></blockquote><br>   4､ 销毁阶段：该阶段主要发生组件销亡的时候，触发componentWillUnmount。<br>      componentWillUnmount()在销毁操作执行之前触发：在组件真正被销毁前调用，在删除组件之前进行清理操作，如计时器和事件监听器。</p>
<blockquote><pre><code><span>&lt;html&gt;</span><br>  <span>&lt;head&gt;</span><br>    <span>&lt;script src=”build/react.js”&gt;</span><span>&lt;/script&gt;</span><br>    <span>&lt;script src=”build/react-dom.js”&gt;</span><span>&lt;/script&gt;</span><br>    <span>&lt;script src=”build/browser.min.js”&gt;</span><span>&lt;/script&gt;</span><br>  <span>&lt;head&gt;</span><br>  <span>&lt;body&gt;</span><br>    <span>&lt;div id=”example”&gt;</span><span>&lt;div&gt;</span><br>    <span>&lt;script type=”text/babel”&gt;</span><br>      <span>class CommentBox extends React.Component {</span><br>        <span>//static defaultProps = { name: ‘Super’ } 此语法为ES7的写法，如果要用到，则需要安装npm install –save-dev babel-preset-stage-0, 在.babelrc中引入。{ “Presets”: [“react”, “es2015”, “stage-0”] }}</span><br>        <span>constructor(props) {</span><br>          <span>console.log(“获取实例的初始状态”);</span><br>          <span>super(props);</span><br>          <span>this.state = {</span><br>            <span>will: true</span><br>          <span>};</span><br>        <span>}</span><br>        <span>componentWillMount(){</span><br>          <span>console.log(“组件即将被渲染到页面”)</span><br>        <span>}</span><br>        <span>handleClick(){</span><br>          <span>this.setState({ will: !this.state.will });</span><br>        <span>}</span><br>        <span>componentDidMount(){</span><br>          <span>console.log(“组件被渲染到页面之后”)</span><br>        <span>}</span><br>        <span>componentWillReceiveProps(nextProps){</span><br>          <span>console.log(“组件快要接收到属性”)</span><br>        <span>}</span><br>        <span>shouldComponentUpdate(){</span><br>          <span>console.log(“是否需要更新”);</span><br>          <span>return true; // true开始准备更新组件，false不更新组件。</span><br>        <span>}</span><br>        <span>componentWillUpdate(){</span><br>          <span>console.log(“组件即将被更新”)</span><br>        <span>}</span><br>        <span>componentDidUpdate(){</span><br>          <span>console.log(“组件更新被渲染到页面”)</span><br>        <span>}</span><br>        <span>render(){</span><br>          <span>console.log(“render”);</span><br>          <span>return(</span><br>            <span>&lt;div&gt;</span><br>              <span>&lt;p onClick={this.handleClick.bind(this)}&gt;</span><span>{this.props.name} {this.state.will ? ‘会’:’不会’} 更好！</span><span>&lt;/p&gt;</span><br>            <span>&lt;/div&gt;</span><br>          <span>);</span><br>        <span>}</span><br>      <span>}</span><br>      <span>CommentBox.defaultProps = { name: ‘Super’ }</span><br>      <span>ReactDOM.render(</span><br>        <span>&lt;CommentBox /&gt;</span><br>        <span>document.getElementById(‘example’)</span><br>      <span>);</span><br>    <span>&lt;/script&gt;</span><br>  <span>&lt;/body&gt;</span><br><span>&lt;/html&gt;</span></code></pre></blockquote>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/12/05/animation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/05/animation/" itemprop="url">CSS3 Animation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-05T00:00:00+08:00">
                2016-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS3/" itemprop="url" rel="index">
                    <span itemprop="name">CSS3</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。<br>animation 属性是一个简写属性，用于设置六个动画属性：<br>animation-name , animation-duration , animation-timing-function , animation-delay , animation-iteration-count , animation-direction<br>注释：请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。</p>
<p><blockquote><pre><code><span>animation: name duration timing-function delay iteration-count direction;</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">一、基本用法</span></p>
<p><blockquote><pre><code><span>div:hover {</span><br>  <span>animation: 1s rainbow;</span><br><span>}</span></code></pre></blockquote><br>上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。</p>
<p><blockquote><pre><code><span>@keyframes rainbow {</span><br>  <span>0% { background: #c00; }</span><br>  <span>50% { background: orange; }</span><br>  <span>100% { background: yellowgreen; }</span><br><span>}</span></code></pre></blockquote><br>上面代码表示，rainbow效果一共有三个状态，分别为起始（0%）、中点（50%）和结束（100%）。如果有需要，完全可以插入更多状态。<br><span style="font-size:18px;font-weight:bold;">二、animation-name</span><br>规定需要绑定到选择器的 keyframe 名称。keyframes关键字用来定义动画的各个状态。</p>
<p><blockquote><pre><code><span>@keyframes rainbow {</span><br>  <span>from { background: #c00 }</span><br>  <span>50% { background: orange }</span><br>  <span>to { background: yellowgreen }</span><br><span>}</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">三、animation-duration</span><br>规定完成动画所花费的时间，以秒或毫秒计。默认值是 0，意味着没有动画效果。</p>
<p><blockquote><pre><code><span>animation-duration: time;</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">四、animation-timing-function</span><br>规定动画的速度曲线。速度曲线定义动画从一套 CSS 样式变为另一套所用的时间。速度曲线用于使变化更为平滑。</p>
<p><blockquote><pre><code><span>animation-timing-function: value;</span></code></pre></blockquote><br>value：linear , ease , ease-in , ease-out , ease-in-out , cubic-bezier(n,n,n,n)<br><span style="font-size:18px;font-weight:bold;">五、animation-delay</span><br>定义动画何时开始。以秒或毫秒计。默认值是 0。<br>提示：允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画。</p>
<p><blockquote><pre><code><span>animation-delay: time;</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">六、animation-iteration-count</span></p>
<p><blockquote><pre><code><span>animation-iteration-count: n|infinite;</span></code></pre></blockquote><br>定义动画的播放次数。默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。</p>
<p><blockquote><pre><code><span>div:hover {</span><br>  <span>animation: 1s rainbow infinite;</span><br><span>}</span></code></pre></blockquote><br>也可以指定动画具体播放的次数，比如3次。</p>
<p><blockquote><pre><code><span>div:hover {</span><br>  <span>animation: 1s rainbow 3;</span><br><span>}</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">七、animation-direction</span></p>
<p><blockquote><pre><code><span>animation-direction: normal|alternate;</span></code></pre></blockquote><br>定义是否应该轮流反向播放动画。normal:动画应该正常播放。alternate:动画应该轮流反向播放。<br>如果 animation-direction 值是 “alternate”，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等）向后播放。<br>注释：如果把动画设置为只播放一次，则该属性没有效果。<br><span style="font-size:18px;font-weight:bold;">八、animation-play-state</span><br>规定动画正在运行还是暂停。paused:动画已暂停。running:动画正在播放。</p>
<p><blockquote><pre><code><span>animation-play-state: paused|running;</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">九、animation-fill-mode</span><br>规定动画在播放之前或之后，其动画效果是否可见。<br>注释：其属性值是由逗号分隔的一个或多个填充模式关键词。</p>
<p><blockquote><pre><code><span>animation-fill-mode : none | forwards | backwards | both;</span></code></pre></blockquote><br>none : 不改变默认行为。<br>forwards : 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。<br>backwards : 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。<br>both : 向前和向后填充模式都被应用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/11/18/transition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/18/transition/" itemprop="url">CSS3 Transition</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-18T00:00:00+08:00">
                2016-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSS3/" itemprop="url" rel="index">
                    <span itemprop="name">CSS3</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>css的transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。</p>
<p><blockquote><pre><code><span>transition ：transition-property transition-duration transition-timing-function transition-delay </span></code></pre></blockquote><br>执行变换的属性：transition-property（过渡效果的 CSS 属性的名称）<br>变换延续的时间：transition-duration（完成过渡效果需要多少秒或毫秒）<br>在延续时间段，变换的速率变化：transition-timing-function（速度效果的速度曲线）<br>变换延迟时间：transition-delay（过渡效果何时开始）<br><span style="font-size:18px;font-weight:bold;">一、transition-property</span><br>transition-property 属性规定应用过渡效果的 CSS 属性的名称。（当指定的 CSS 属性改变时，过渡效果将开始）。<br>提示：过渡效果通常在用户将鼠标指针浮动到元素上时发生。<br>注释：请始终设置 transition-duration 属性，否则时长为 0，就不会产生过渡效果。</p>
<p><blockquote><pre><code><span>transition-property: none|all|property;</span></code></pre></blockquote><br>1)none(没有属性改变)；<br>2)all（所有属性改变）其默认值；<br>3)property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。<br><span style="font-size:18px;font-weight:bold;">二、transition-duration</span><br>transition-duration 属性规定完成过渡效果需要花费的时间（以秒或毫秒计）。</p>
<p><blockquote><pre><code>transition-duration: time;</code></pre></blockquote><br>time：规定完成过渡效果需要花费的时间（以秒或毫秒计）。默认值是 0，意味着不会有效果。<br><span style="font-size:18px;font-weight:bold;">三、transition-timing-function</span><br>transition-timing-function 属性规定过渡效果的速度曲线。该属性允许过渡效果随着时间来改变其速度。</p>
<p><blockquote><pre><code><span>transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);</span></code></pre></blockquote><br>1)linear：规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）<br>2)ease：规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）<br>3)ease-in：规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）<br>4)ease-out：规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）<br>5)ease-in-out：规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）<br>6)cubic-bezier(n,n,n,n)：在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值<br><span style="font-size:18px;font-weight:bold;">四、transition-delay</span><br>transition-delay 属性规定过渡效果何时开始。<br>transition-delay 值以秒或毫秒计。</p>
<p><blockquote><pre><code><span>transition-delay: time;</span></code></pre></blockquote><br>time：规定在过渡效果开始之前需要等待的时间，以秒或毫秒计。默认大小是”0”，也就是变换立即执行，没有延迟。<br><img src="http://oo6ltjdyl.bkt.clouddn.com/transition-suji.png" alt=""><br>transition的优点在于简单易用，但是它有几个很大的局限。<br>（1）transition需要事件触发，所以没法在网页加载时自动发生。<br>（2）transition是一次性的，不能重复发生，除非一再触发。<br>（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。<br>（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/11/11/promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/11/promise/" itemprop="url">Promise 对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-11T00:00:00+08:00">
                2016-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。<br>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。<br>Promise对象有以下两个特点。<br>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。<br><img src="http://oo6ltjdyl.bkt.clouddn.com/755677508.png" alt=""><br>Promise是一个构造函数，有all、reject、resolve方法，原型上有then、catch方法。用Promise new出来的对象肯定就有then、catch方法。<br>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。<br>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<br>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。<br><span style="font-size:18px;font-weight:bold;">then用法</span><br>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p>
<blockquote><pre><code><span>promise.then(function(value) {</span><br>  <span>// success</span><br><span>}, function(error) {</span><br>  <span>// failure</span><br><span>});</span></code></pre></blockquote><br>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。<br><blockquote><pre><code><span>function runAsync1(){</span><br>  <span>var p = new Promise(function(resolve, reject){</span><br>    <span>setTimeout(function(){</span><br>      <span>console.log(‘执行完成1’);</span><br>      <span>resolve(‘数据1’);</span><br>    <span>}, 1000)</span><br>  <span>});</span><br>  <span>return p;</span><br><span>}</span><br><span>function runAsync2(){</span><br>  <span>var p = new Promise(function(resolve, reject){</span><br>    <span>setTimeout(function(){</span><br>      <span>console.log(‘执行完成2’);</span><br>      <span>resolve(‘数据2’);</span><br>    <span>}, 2000)</span><br>  <span>});</span><br>  <span>return p;</span><br><span>}</span><br><span>runAsync1().then(function(data){</span><br>  <span>console.log(data);</span><br><span>})</span><br><span>//执行完成</span><br><span>//数据</span></code></pre></blockquote><br>在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧，在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。<br><blockquote><pre><code><span>runAsync1().then(function(data){</span><br>  <span>console.log(data);</span><br>  <span>return ‘直接返回数据’;</span><br><span>})</span><br><span>.then(function(data){</span><br>  <span>console.log(data);</span><br><span>});</span><br><span>//执行完成</span><br><span>//数据</span><br><span>//直接返回数据</span></code></pre></blockquote><br>上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。<br>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。<br><span style="font-size:18px;font-weigth:bold;">Reject状态</span><br>Reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。<br><blockquote><pre><code><span>function getNumber(){</span><br>  <span>var p = new Promise(function(resolve, reject){</span><br>    <span>setTimeout(function(){</span><br>      <span>var num = Math.ceil(Math.random()*10);</span><br>      <span>if(num&lt;=5){ resolve(num); }</span><br>      <span>else{ reject(‘数字太大了’); }</span><br>    <span>}, 2000);</span><br>  <span>});</span><br>  <span>return p; </span><br><span>}</span><br><span>getNumber().then(function(data){</span><br>  <span>console.log(‘resolved’);</span><br>  <span>console.log(data);</span><br><span>}, function(reason, data){</span><br>  <span>console.log(‘rejected’);</span><br>  <span>console.log(reason);</span><br><span>});</span></code></pre></blockquote><br>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。<br><span style="font-size:18px;font-weigth:bold;">catch方法</span><br>用于指定发生错误时的回调函数。返回一个 Promise 对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。<br><blockquote><pre><code><span>getNumber().then(function(data){</span><br>  <span>console.log(‘resolved’);</span><br>  <span>console.log(data);</span><br>  <span>console.log(somedata); //此处的somedata未定义</span><br><span>}).catch(function(reason){</span><br>  <span>console.log(‘rejected’);</span><br>  <span>console.log(reason);</span><br><span>});</span><br><span>//resolved</span><br><span>//5</span><br><span>//rejected</span><br><span>//ReferenceError: somedata is not defined</span></code></pre></blockquote><br><span style="font-size:18px;font-weigth:bold;">all方法</span><br>all方法用于将多个Promise实例，包装成一个新的Promise实例。<br><blockquote><pre><code><span>var p = Promise.all([p1, p2, p3]);</span></code></pre></blockquote><br>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。）<br>p的状态由p1、p2、p3决定，分成两种情况。<br>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。<br><blockquote><pre><code><span>Promise</span><br><span>.all([runAsync1(), runAsync2(), runAsync3()])</span><br><span>.then(function(results){</span><br>  <span>console.log(results);</span><br><span>});</span><br><span>//执行完成1</span><br><span>//执行完成2</span><br><span>//[‘数据1’,’数据2’]</span></code></pre></blockquote><br><span style="font-size:18px;font-weigth:bold;">race方法</span><br>race方法「谁跑的快，以谁为准执行回调」，那个率先改变的 Promise 实例的返回值，就传递给回调函数。<br><blockquote><pre><code><span>Promise</span><br><span>.race([runAsync1(), runAsync2()])</span><br><span>.then(function(results){</span><br><span>console.log(results);</span><br><span>});</span><br><span>//执行完成1</span><br><span>//数据1</span><br><span>//执行完成2</span></code></pre></blockquote>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/10/21/es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/21/es6/" itemprop="url">ES6常用特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-21T00:00:00+08:00">
                2016-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。<br>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。<br>ES6常用特性：let, const, class, extends, super, arrow functions, destructuring, default, rest arguments<br>1､let命令<br>  let用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。<br>  <blockquote><pre><code><span>{ </span><br>    <span>var a = 10;</span><br>    <span>let b = 20;</span><br>  <span>}</span><br>  <span>a // 10</span><br>  <span>b // ReferenceError: b is not defined.</span></code></pre></blockquote><br>  上面代码中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。<br>  另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量。<br>  <blockquote><pre><code><span>var a = [];</span><br>  <span>for(var i=0; i&lt; 10; i++){</span><br>    <span>a[i] = function(){</span><br>      <span>console.log(i);</span><br>    <span>}</span><br>  <span>}</span><br>  <span>a&#91;6&#93;&#40;&#41; //10</span></code></pre></blockquote><br>  上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。<br>  <blockquote><pre><code><span>var a = [];</span><br>  <span>for(let i=0; i&lt; 10; i++){</span><br>    <span>a[i] = function(){</span><br>      <span>console.log(i);</span><br>    <span>}</span><br>  <span>}</span><br>  <span>a&#91;6&#93;&#40;&#41; //6</span></code></pre></blockquote><br>  上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。<br>2､const 命令<br>  const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>  <blockquote><pre><code><span>const PI = 3.1415;</span><br><span>PI; //3.1415</span><br><span>PI = 3 //TypeError: Assignment to constant variable.</span></code></pre></blockquote><br>  const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br>  <blockquote><pre><code><span>const foo; //SyntaxError: Missing initializer in const declaration</span></code></pre></blockquote><br>  上面代码中，对于const来说，只声明不赋值，就会报错。<br>3､class、extends、super()<br>  ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。<br>  <blockquote><pre><code><span>class Animal {</span><br>    <span>constructor(){</span><br>      <span>this.type = ‘animal’</span><br>    <span>}</span><br>    <span>say(say){</span><br>      <span>console.log(this.type + ‘says’ + say)</span><br>    <span>}</span><br>  <span>}</span><br>  <span>let animal = new Animal()</span><br>  <span>animal.says(‘hello’)  // animal says hello </span><br>  <span>class Cat extends Animal{</span><br>    <span>constructor(){</span><br>      <span>super()</span><br>      <span>this.type = ‘cat’</span><br>    <span>}</span><br>  <span>}</span><br>  <span>let cat = new Cat()</span><br><span>cat.says(‘hello’) //cat says hello</span></code></pre></blockquote><br>上面代码中，首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实力对象可以共享的。<br>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。<br>super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。<br>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。<br>4､arrow functions<br>  <blockquote><pre><code><span>function(x, y) { </span><br>  <span>x++;</span><br>  <span>y–;</span><br>  <span>return x + y;</span><br><span>}</span><br><span>(x, y) =&gt; {x++; y–; return x+y} // ES6</span></code></pre></blockquote><br>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。</p>
<blockquote><pre><code><span>class Animal {</span><br>  <span>constructor(){</span><br>    <span>this.type = ‘animal’</span><br>  <span>}</span><br>  <span>say(say){</span><br>    <span>setTimeout( () =&gt; {</span><br>      <span>console.log(this.type + ‘says’ + say)</span><br>    <span>}, 1000)</span><br>  <span>}</span><br><span>}</span><br><span>let animal = new Animal()</span><br><span>animal.says(‘hi’)  // animal says hi </span></code></pre></blockquote><br>5､destructuring（解构）<br>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。<br><blockquote><pre><code><span>let [a, b, c] = [1, 2, 3];</span><br><span>let [ , , third] = [“foo”, “bar”, “baz”]; </span><br><span>third; //baz</span><br><span>let [head, …tail] = [1, 2, 3, 4];</span><br><span>head // 1</span><br><span>tail // [2, 3, 4]</span></code></pre></blockquote><br>上面代码中，可以从数组中提取值，按照对应位置，对变量赋值。<br>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。<br><blockquote><pre><code><span>let [a, [b], d] = [1, [2, 3], 4];</span><br><span>a //1</span><br><span>b //2</span><br><span>d //4</span></code></pre></blockquote><br>解构不仅可以用于数组，还可以用于对象。<br><blockquote><pre><code><span>let dog = {type: ‘animal’, many: 2}</span><br><span>let { type, many} = dog</span><br><span>console.log(type, many)</span></code></pre></blockquote><br>6､default参数<br>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。参数变量是默认声明的，所以不能用let或const再次声明。否则会报错。使用参数默认值时，函数不能有同名参数。<br><span style="color:red;">如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</span><br><blockquote><pre><code><span>function animal(type = ‘cat’){</span><br>  <span>console.log(type)</span><br><span>}</span><br><span>animal() //cat</span></code></pre></blockquote><br>7､rest参数<br>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。<br><blockquote><pre><code><span>function animals(…types){</span><br>  <span>console.log(types)</span><br><span>}</span><br><span>animals(‘cat’, ‘dog’, ‘fish’) //[“cat”, “dog”, “fish”]</span></code></pre></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/10/14/bh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/14/bh/" itemprop="url">北海有海，没有故事</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-14T00:00:00+08:00">
                2016-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/心情/" itemprop="url" rel="index">
                    <span itemprop="name">心情</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果，我来不及认真地年轻，<br>待明白过来时，只能选择认真地老去。<br>                            ——三毛。<br>飞机降落北海福成机场，才真正意识到。<br>一个人，一张机票，小白鞋牛仔裤一个背包，一台单反，北海之旅开启。<br>一个人的旅行或许会有些许害怕，但它简简单单、干干净净，也没有任何外物的叨扰。</p>
<p>北海对我而言，莫过于有之向往的大海，面朝大海，春暖开花。<br>我的个性并不孤僻，也喜欢交朋友，但是却真心喜欢一个人的时光。因为缺乏耐心又不喜欢等人。</p>
<p><span style="font-size:16;font-weight:bold;">最美的日落。</span><br><img src="http://oo6ltjdyl.bkt.clouddn.com/WechatIMG2.jpg" alt=""><br>民宿的老板娘得知我一个女生独自旅游，专门给我留了二楼一间带小阳台的房间，满满的幸福感。<br>没有攻略，没有同伴，无须等待，睡到自然醒，睡个午觉，等到太阳下山，出门过条街，就是北海的银滩。<br>银滩没有到处收钱的沙滩椅，为数不多的沙滩车，可以肆无忌惮的躺在海边，静静的吹着海风，看着人来人往的人群，静静的看着日落，何偿不是一种幸福。</p>
<p><span style="font-size:16;font-weight:bold;">困在涠洲岛的日子。</span><br>码头，上岛，涠洲岛的日子，没有想像的惊艳。<br>去的时候，五彩滩不知什么原因被封，很多岛屿都被村民占位，摆满沙滩椅，海上围起来游泳，海上也是飘满各种垃级。<br>菜市场买海鲜，并没有所谓的便宜。听人说这几年涠洲岛发展很快，随着越来越多的游客，却也带了各种混乱。<br>以至于最后一天有点迫不及待的出岛。</p>
<p>在北海的日子，看到最美的日出和日落，也算是为这场旅行带来不少欢乐。<br>这里没有攻略，没有景点介绍，因为去过的景点少，每天都是静静的呆着发呆，听人弹弹吉它。<br>这里只有一个人的碎碎念，有时候，有些话，写得出，却说不出。<br>我陷在自己的茧里，出不去。零零散散的写的自己的心情，给想看的看得懂的人看，无需强求。<br>毕竟有些东西，只有自己懂。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/09/16/closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/16/closure/" itemprop="url">JavaScript 闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-16T00:00:00+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、什么是闭包？<br>官方的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。<br>这句话通俗的来说就是：JavaScript中所有的function都是一个闭包。不过一般来说，嵌套的function所产生的闭包更为强大，也是大部分时候我们所谓的“闭包”。</p>
<p><blockquote><pre><code><span>function a() {</span><br>  <span>var i = 0;</span><br>  <span>function b() { console.log(++i); } </span><br>  <span>return b;</span><br><span>}</span><br><span>var c = a();</span><br><span>c();</span></code></pre></blockquote><br>这段代码有两个特点：<br>1、函数b嵌套在函数a内部；<br>2、函数a返回函数b。<br>这样在执行完var c=a()后，变量c实际上是指向了函数b，再执行c()后就会console.log显示i的值(第一次为1)。这段代码其实就创建了一个闭包，为什么？因为函数a外的变量c引用了函数a内的函数b，就是说：<br><span style="color:red;">当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。</span><br>所谓“闭包”，就是在构造函数体内定义另外的函数作为目标对象的方法函数，而这个对象的方法函数反过来引用外层函数体中的临时变量。这使得只要目标 对象在生存期内始终能保持其方法，就能间接保持原构造函数体当时用到的临时变量值。尽管最开始的构造函数调用已经结束，临时变量的名称也都消失了，但在目 标对象的方法内却始终能引用到该变量的值，而且该值只能通这种方法来访问。即使再次调用相同的构造函数，但只会生成新对象和方法，新的临时变量只是对应新 的值，和上次那次调用的是各自独立的。<br>在上面的例子中，由于闭包的存在使得函数a返回后，a中的i始终存在，这样每次执行c()，i都是自加1后console.log出i的值。<br>二、使用闭包的注意点<br>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/09/09/js-scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/09/js-scope/" itemprop="url">JavaScript Scope 作用域和作用域链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-09T00:00:00+08:00">
                2016-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、作用域<br>作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，在JavaScript中变量的作用域有全局作用域和局部作用域。<br>JavaScript并没有块及的作用域，只有函数级作用域：变量在声明它们的函数体及其子函数内是可见的。<br>变量没有在函数内声明或者声明的时候没有带var就是全局变量，拥有全局作用域，window对象的所有属性拥有全局作用域；在代码任何地方都可以访问，函数内部声明并且以var修饰的变量就是局部变量，只能在函数体内使用，函数的参数虽然没有使用var但仍然是局部变量。<br><span style="font-size:16px;font-weight:bold;">1､全局作用域（Global Scope）</span><br>在代码中任何地方都能访问到的对象拥有全局作用域。<br>（1）最外层函数和在最外层函数外面定义的变量拥有全局作用域</p>
<p><blockquote><pre><code><span>var a = 3;</span><br><span>function Fn(){</span><br>  <span>var b = 4;</span><br>  <span>function subFn(){</span><br>    <span>console.log(b);</span><br>  <span>};</span><br>  <span>subFn();</span><br><span>}</span><br><span>console.log(a); //3</span><br><span>console.log(typeof b); //undefined 使用typeof b，是因为对于没有定义的变量，浏览器会抛出错误，并且阻塞浏览器继续执行后续代码的。</span><br><span>Fn(); //4</span><br><span>subFn(); //报错</span></code></pre></blockquote><br>（2）所有末定义直接赋值的变量自动声明为拥有全局作用域</p>
<p><blockquote><pre><code><span>function Fn(){</span><br>  <span>var a = 3;</span><br>  <span>b = 4;</span><br>  <span>console.log(a);</span><br><span>}</span><br><span>Fn(); //3</span><br><span>console.log(b); //4</span><br><span>console.log(a); //报错</span></code></pre></blockquote><br>（3）所有window对象的属性拥有全局作用域<br>一般情况下，window对象的内置属性都拥有全局作用域，例如window.name、window.location、window.top等等。<br><span style="font-size:16px;font-weight:bold;">2､局部作用域（Local Scope）</span>　<br>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域。</p>
<p><blockquote><pre><code><span>function Fn(){</span><br>  <span>var b = 3;</span><br>  <span>function subFn(){</span><br>    <span>console.log(b);</span><br>  <span>}</span><br>  <span>subFn();</span><br><span>}</span><br><span>console.log(typeof b); //undefined</span><br><span>subFn() //报错</span></code></pre></blockquote><br>二、作用域链<br>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。<br>当一个函数创建后，它实际上保存一个作用域链，并且作用域链会被创建此函数的作用域中可访问的数据对象填充。</p>
<p><blockquote><pre><code><span>name=”a”; </span><br><span>function test(){</span><br>  <span>var name=”b”;</span><br>  <span>function local1(){</span><br>    <span>var name=”c”;</span><br>    <span>console.log(name); </span><br>  <span>}</span><br>  <span>function local2(){ </span><br>    <span>console.log(name); </span><br>  <span>}</span><br>  <span>local1(); </span><br>  <span>local2(); </span><br><span>} </span><br><span>test(); </span></code></pre></blockquote><br>当执行local1()时，将创建函数local1的执行环境(调用对象),并将该对象置于作用域链开头，然后将函数test的调用对象链接在之后，最后是全局对象。然后从链开头寻找变量name,<br>很明显作用域链是： local1()-&gt;test()-&gt;window,所以name是”a”<br>但执行local2()时，作用域链是： local2()-&gt;test()-&gt;window,所以name是”b”</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/08/26/number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/26/number/" itemprop="url">JavaScript Number 对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-26T00:00:00+08:00">
                2016-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Number 对象是原始数值的包装对象。当 Number() 和运算符 new 一起作为构造函数使用时，它返回一个新创建的 Number 对象。如果不用 new 运算符，把 Number() 作为一个函数来调用，它将把自己的参数转换成一个原始的数值，并且返回这个值（如果转换失败，则返回 NaN）。</p>
<blockquote><pre><code><span>var myNum=new Number(value);</span><br><span>var myNum=Number(value);</span></code></pre></blockquote><br>参数 value 是要创建的 Number 对象的数值，或是要转换成数字的值。<br>Number 对象方法<br>1)toString(radix)：把一个 Number 对象转换为一个字符串，使用指定的基数，并返回结果。<br>  radix: 可选。规定表示数字的基数，使 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。但是要注意，如果该参数是 10 以外的其他值，则 ECMAScript 标准允许实现返回任意值。<br><blockquote><pre><code><span>var number = new Number(1354);</span><br><span>console.log(number.toString()) // 1354</span></code></pre></blockquote><br>2)toLocaleString()：把一个 Number 对象转换为本地格式的字符串。数字的字符串表示，由实现决定，根据本地规范进行格式化，可能影响到小数点或千分位分隔符采用的标点符号。<br><blockquote><pre><code><span>var number = new Number(1354321);</span><br><span>console.log(number.toLocaleString()) // 1,354,321</span></code></pre></blockquote><br>3)toFixed(num)：把 Number 四舍五入为指定小数位数的数字，结果的小数点后有指定位数的数字。<br>  num: 规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。当 num 太小或太大时抛出异常 RangeError。<br><blockquote><pre><code><span>var number = new Number(135.4321);</span><br><span>console.log(number.toFixed()) // 135</span><br><span>console.log(number.toFixed(1)) // 135.4</span><br><span>console.log(number.toFixed(-1)) // RangeError</span></code></pre></blockquote><br>4)toExponential(num)：把对象的值转换成指数计数法。<br>  num: 规定指数计数法中的小数位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将使用尽可能多的数字。<br>  采用指数计数法，即小数点之前有一位数字，小数点之后有 num 位数字。该数字的小数部分将被舍入，必要时用 0 补足，以便它达到指定的长度。<br><blockquote><pre><code><span>var number = new Number(13200);</span><br><span>console.log(number.toExponential(0)) // 1e+4</span><br><span>console.log(number.toExponential(1)) // 1.3e+4 </span><br><span>console.log(number.toExponential(5)) // 1.32000e+4</span><br><span>console.log(number.toExponential(-1)) // RangeError</span></code></pre></blockquote><br>5)toPrecision(num)：在对象的值超出指定位数时将其转换为指数计数法。<br>  num: 规定必须被转换为指数计数法的最小位数。该参数是 1 ~ 21 之间（且包括 1 和 21）的值。有效实现允许有选择地支持更大或更小的 num。如果省略了该参数，则调用方法 toString()，而不是把数字转换成十进制的值。如果 num 足够大，能够包括 NumberObject 整数部分的所有数字，那么返回的字符串将采用定点计数法。否则，采用指数计数法，即小数点前有一位数字，小数点后有 num-1 位数字。必要时，该数字会被舍入或用 0 补足。当 num 太小或太大时抛出异常 RangeError。<br><blockquote><pre><code><span>var number = new Number(1320);</span><br><span>console.log(number.toPrecision()) //1320</span><br><span>console.log(number.toPrecision(3)) //1.32e+3</span><br><span>console.log(number.toPrecision(8)) //1320.0000</span></code></pre></blockquote><br>6)valudOf()：返回一个 Number 对象的基本数字值。可以字符串返回数字，字符串的输出通常等于该数字。当调用该方法的对象不是 Number 时抛出 TypeError 异常。<br><blockquote><pre><code><span>var number = new Number(‘123’);</span><br><span>console.log(number.valueOf()) // 123</span><br><span>var number = new Number(‘2fdsf’);</span><br><span>console.log(number.valueOf()) // NaN</span></code></pre></blockquote>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/08/12/filter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/12/filter/" itemprop="url">AngularJS中filter过滤器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-12T00:00:00+08:00">
                2016-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/AngularJs/" itemprop="url" rel="index">
                    <span itemprop="name">AngularJs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>过滤器扮演着数据翻译的角色。一般他们主要用在数据需要格式化成本地格式的时候。它参照了UNIX过滤的规则，并且也实现了“|”（管道）语法。<br>1､在模板中使用filter<br>  我们可以直接在双括号中使用filter，跟在表达式后面用 | 分割。<br>  <blockquote><pre><code><span>语法：{{ expression | filter }}</span></code></pre></blockquote><br>  多个filter连用，上一个filter的输出将作为下一个filter的输入。<br>  <blockquote><pre><code><span>语法：{{ expression | filter | filter | filter | ... }}</span></code></pre></blockquote><br>  filter可以接收参数。参数用 : 进行分割。<br>  <blockquote><pre><code><span>语法：{{ expression | filter:argument1:argument2:argument3:...}}</span></code></pre></blockquote><br>2､在controller和service中使用filter<br>  ng提供一个$filter服务可以用来调用所需的filter，你只需注入一个$filter就够了。<br>  <blockquote><pre><code><span>app.controller(‘filter’,function($scope,$filter){</span><br>    <span>$scope.num = $filter(‘currency’)(123534);</span><br>　　 <span>$scope.date = $filter(‘date’)(new Date());</span><br>  <span>}</span></code></pre></blockquote></p>
<p>ng内置过滤器<br>1､currency（货币处理）：使用currency可以将数字格式化为货币，默认是美元符号，你可以自己传入所需的符号。<br>  <blockquote><pre><code><span>{{ num | currency : '￥' }}</span></code></pre></blockquote><br>2､date (日期格式化)：y M d h m s E 分别表示 年 月 日 时 分 秒 星期，你可以自由组合。也可以使用不同的个数来限制格式化的位数。<br>  <blockquote><pre><code><span>{{ date | date : 'yyyy-MM-dd hh:mm:ss EEEE' }}</span></code></pre></blockquote><br>3､filter（匹配子串）：用来处理一个数组，然后可以过滤出含有某个子串的元素，作为一个子数组来返回。<br>4､json（格式化json对象）：json过滤器可以把一个js对象格式化为json字符串，没有参数。<br>  <blockquote><pre><code><span>{{ json | json }}</span></code></pre></blockquote><br>5､limitTo（限制数组长度或字符串长度）：用来截取数组或字符串，接收一个参数用来指定截取的长度。<br>  <blockquote><pre><code><span>{{ limit | limitTo : 2 }} </span></code></pre></blockquote><br>6､lowercase（小写）：把数据转化为小写。<br>7､uppercase（大写）：把数据转化为大写。<br>8､number（格式化数字）：可以为一个数字加上千位分割，像这样，123,456,789。同时接收一个参数，可以指定小float类型保留几位小数：<br>  <blockquote><pre><code><span>{{ num | number : 2 }}</span></code></pre></blockquote><br>9､orderBy（排序）：可以将一个数组中的元素进行排序，接收一个参数来指定排序规则，参数可以是一个字符串，表示以该属性名称进行排序。可以是一个函数，定义排序属性。还可以是一个数组，表示依次按数组中的属性值进行排序（若按第一项比较的值相等，再按第二项比较）。</p>
<blockquote><pre><code><span>&lt;div ng-init=”list = [‘Chrome’, ‘Safari’, ‘Firefox’, ‘IE’] “&gt;</span><br>  <span>&lt;p&gt;</span><span>Number formatting: {{ 1234567890 | number }} </span><span>&lt;/p&gt;</span><br>  <span> Array filtering</span><span>&lt;input ng-model=”predicate”&gt;</span><br>  <span>{{ list | filter:predicate | json }}</span><br><span>&lt;/div&gt;</span></code></pre></blockquote><br>自定义过滤器<br>使用module的filter方法，返回一个函数，该函数接收输入值，并返回处理后的结果。<br><blockquote><pre><code><span>angular.module(‘app’, []).filter(‘reverse’, function() {</span><br>  <span>return function(input, uppercase) {</span><br>    <span>var out = “”;</span><br>    <span>for (var i = 0; i &lt; input.length; i++) {</span><br>      <span>out = input.charAt(i) + out;</span><br>    <span>}</span><br>    <span>if (uppercase) {</span><br>      <span>out = out.toUpperCase();</span><br>    <span>}</span><br>    <span>return out;</span><br>  <span>}</span><br><span>}).controller(‘Ctrl’,function($scope) {</span><br>  <span>$scope.greeting = ‘hello’;</span><br><span>})</span></code></pre></blockquote><br><blockquote><pre><code><span>HTML</span><br><span>&lt;html ng-app=”app”&gt;</span><br>  <span>&lt;head&gt;</span><span>&lt;/head&gt;</span><br>  <span>&lt;body&gt;</span><br>  <span>&lt;div ng-controller=”Ctrl&gt;</span><br>    <span>&lt;p&gt;</span><span>&lt;input ng-model=”greeting” type=”greeting”&gt;</span><span>&lt;/p&gt;</span><br>    <span>&lt;p&gt;</span><span>No filter: {{greeting}}</span><span>&lt;/p&gt;</span><br>    <span>&lt;p&gt;</span><span>Reverse: {{greeting|reverse}}</span><span>&lt;/p&gt;</span><br>    <span>&lt;p&gt;</span><span>Reverse + uppercase: {{greeting|reverse:true}}</span><span>&lt;/p&gt;</span><br>  <span>&lt;/div&gt;</span><br>  <span>&lt;/body&gt;</span><br><span>&lt;/html&gt;</span></code></pre></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="socat" />
          <p class="site-author-name" itemprop="name">socat</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">socat</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
