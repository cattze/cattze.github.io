<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="socat">
<meta property="og:url" content="http:socat.cc/index.html">
<meta property="og:site_name" content="socat">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="socat">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http:socat.cc/"/>





  <title>socat</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">socat</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/05/19/arc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/19/arc/" itemprop="url">Canvas 圆形</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-19T00:00:00+08:00">
                2017-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/canvas/" itemprop="url" rel="index">
                    <span itemprop="name">canvas</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>arc() 方法创建弧/曲线（用于创建圆或部分圆）<br>提示: 如需通过 arc() 来创建圆，请把起始角设置为 0，结束角设置为2&lowast;<span>Math.PI</span>。<br>提示: 请使用 stroke() 或 fill() 方法在画布上绘制实际的弧。<br><img src="http://oo6ltjdyl.bkt.clouddn.com/img_arc.gif" alt=""><br>中心: arc(100,75,50,0&lowast;<span>Math.PI</span>,1.5&lowast;<span>Math.PI</span>)<br>起始角: arc(100,75,50,0,1.5&lowast;<span>Math.PI</span>)<br>结束角: arc(100,75,50,0&lowast;<span>Math.PI</span>,1.5&lowast;<span>Math.PI</span>)<br><span style="font-size:16px;font-weigh:bold;">JavaScript 语法： ctx.arc(x,y,r,sAngle,eAngle,counterclockwise);</span><br>x: 圆的中心的 x 坐标。<br>y: 圆的中心的 y 坐标。<br>r: 圆的半径<br>sAngle：起始角，以弧度计（弧的圆形的三点钟位置是 0 度）（弧度制，比如0，0.5*Math.PI…..）<br>eAngle: 结束角，以弧度计。<br>counterclockwise：可选。规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针。不写默认false<br><span style="font-size:16px;font-weigh:bold;">1.如图绘制圆心（0,10）半径100，从0π到0.5π顺时针绘制一段圆弧</span></p>
<p><blockquote><pre><code><br>  <span>ctx.strokeStyle=’red’;</span><br>  <span>ctx.arc(0,10,100,0,0.5*Math.PI);</span><br>  <span>ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/4564C7F839E1.png" alt=""><br><span style="font-size:16px;font-weigh:bold;">2.如图绘制圆心（110,110）半径100，从0π到0.5π逆时针绘制一段圆弧</span></p>
<p><blockquote><pre><code><br>  <span>ctx.strokeStyle=’red’;</span><br>  <span>ctx.arc(110,110,100,0,0.5*Math.PI,true);</span><br>  <span>ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/5BB82211BEB1.png" alt=""><br><span style="font-size:16px;font-weigh:bold;">3.和绘制直线一样，ctx.fill();默认会把首位相连，在填充上颜色</span></p>
<p><blockquote><pre><code><br>  <span>ctx.strokeStyle=’black’;</span><br>  <span>ctx.lineWidth=5;</span><br>  <span>ctx.arc(110,110,100,0,0.5*Math.PI,true);</span><br>  <span>ctx.fillStyle=”red”;</span><br>  <span>ctx.fill();</span><br>  <span>ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/F69B433E9651.png" alt=""><br><span style="font-size:16px;font-weigh:bold;">&gt;4.可以不需要绘制context.stroke()，直接填充颜色，只是没有了边界</span></p>
<p><blockquote><pre><code><br>  <span>ctx.strokeStyle=’black’;</span><br>  <span>ctx.lineWidth=5;</span><br>  <span>ctx.arc(110,110,100,0,0.5*Math.PI,true);</span><br>  <span>ctx.fillStyle=”red”;</span><br>  <span>ctx.fill();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/123.jpg" alt=""><br><span style="font-size:16px;font-weigh:bold;">beginPath();closePath();  使得路径首位相连<br>    beginPath（）： 标志开始一个路径<br>    closePath（）；表中结束一个路径，如果没有首位相连，则连起来</span></p>
<p><blockquote><pre><code><br>  <span>ctx.strokeStyle=’black’;</span><br>  <span>ctx.lineWidth=5;</span><br>  <span>ctx.beginPath();</span><br>  <span>ctx.arc(110,110,100,0,0.5*Math.PI,true);</span><br>  <span>ctx.closePath();</span><br>  <span>ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/1234.jpg" alt=""><br><span style="font-size:16px;font-weigh:bold;">6.closePath()可以不写，不影响状态的锁定，不过不会自动封闭线的两端了</span></p>
<p><blockquote><pre><code><br>  <span>ctx.strokeStyle=’black’;</span><br>  <span>ctx.lineWidth=5;</span><br>  <span>context.beginPath();</span><br>  <span>ctx.arc(110,110,100,0,0.5*Math.PI,true);</span><br>  <span>ctx.fillStyle=”red”;</span><br>  <span>ctx.fill();</span><br>  <span>ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/12345.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/05/13/line/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/13/line/" itemprop="url">Canvas 线性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-13T00:00:00+08:00">
                2017-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/canvas/" itemprop="url" rel="index">
                    <span itemprop="name">canvas</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span style="font-size:16px;font-weigh:bold;">1､lineCap 属性</span><br>lineCap 属性设置或返回线条末端线帽的样式。<br>注意：”round” 和 “square” 值会使线条略微变长。<br>butt 默认。向线条的每个末端添加平直的边缘。<br>round 向线条的每个末端添加圆形线帽。<br>square  向线条的每个末端添加正方形线帽。</p>
<p><blockquote><pre><code><br>  <span>//butt</span><br>  <span>ctx.lineWidth = 10;</span><br>  <span>ctx.beginPath();</span><br>  <span>ctx.lineCap = ‘butt’;</span><br>  <span>ctx.moveTo(60, 30);</span><br>  <span>ctx.lineTo(200, 30);</span><br>  <span>ctx.fillText(‘butt’, 10, 35);</span><br>  <span>ctx.stroke();</span><br>  <span>//round</span><br>  <span>ctx.lineWidth = 10;</span><br>  <span>ctx.beginPath();</span><br>  <span>ctx.lineCap = ‘round’;</span><br>  <span>ctx.moveTo(60, 60);</span><br>  <span>ctx.lineTo(200, 60);</span><br>  <span>ctx.fillText(‘round’, 10, 65);</span><br>  <span>ctx.stroke();</span><br>  <span>//square</span><br>  <span>ctx.lineWidth = 10;</span><br>  <span>ctx.beginPath();</span><br>  <span>ctx.lineCap = ‘square’;</span><br>  <span>ctx.moveTo(60, 90);</span><br>  <span>ctx.lineTo(200, 90);</span><br>  <span>ctx.fillText(‘square’, 10, 95);</span><br>  <span> ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/2345.jpg" alt=""><br><span style="font-size:16px;font-weigh:bold;">2､lineJoin 属性</span><br>lineJoin 属性设置或返回所创建边角的类型，当两条线交汇时。<br>注意：”miter” 值受 miterLimit 属性的影响。<br>bevel 创建斜角。<br>round 创建圆角。<br>miter 默认。创建尖角。</p>
<p><blockquote><pre><code><br>  <span>//miter</span><br>  <span>ctx.lineWidth = 10;</span><br>  <span>ctx.beginPath();</span><br>  <span>ctx.lineJoin = ‘miter’;</span><br>  <span>ctx.moveTo(60, 30);</span><br>  <span>ctx.lineTo(100, 30);</span><br>  <span>ctx.lineTo(100, 100);</span><br>  <span>ctx.fillText(‘miter’, 10, 35);</span><br>  <span>ctx.stroke();</span><br>  <span>//round</span><br>  <span>ctx.lineWidth = 10;</span><br>  <span>ctx.beginPath();</span><br>  <span>ctx.lineJoin = ‘round’;</span><br>  <span>ctx.moveTo(160, 30);</span><br>  <span>ctx.lineTo(200, 30);</span><br>  <span>ctx.lineTo(200, 100);</span><br>  <span>ctx.fillText(‘round’, 120, 35);</span><br>  <span>ctx.stroke();</span><br>  <span>//bevel</span><br>  <span>ctx.lineWidth = 10;</span><br>  <span>ctx.beginPath();</span><br>  <span>ctx.lineJoin = ‘bevel’;</span><br>  <span>ctx.moveTo(260, 30);</span><br>  <span>ctx.lineTo(300, 30);</span><br>  <span>ctx.lineTo(300, 100);</span><br>  <span>ctx.fillText(‘bevel’, 220, 35);</span><br>  <span>ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/23456.jpg" alt=""><br><span style="font-size:16px;font-weigh:bold;">3､lineWidth 属性</span><br>lineWidth 属性设置或返回当前线条的宽度，以像素计。<br>线宽是指给定路径的中心到两边的粗细。就是在路径的两边各绘制线宽的一半。<br>在Canvas中绘制1个像素的线条时，坐标位置需要错开0.5个像素。<br>在Canvas中绘制路径（线段）时，后面显式设置的lineWidth会覆盖前面的值。<br><span style="font-size:16px;font-weigh:bold;">4､miterLimit 属性</span><br>默认值：10, number 正数。规定最大斜接长度。如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 “bevel” 类型来显示。以最大斜接长度 5 绘制线条：</p>
<p><blockquote><pre><code><br>  <span>ctx.lineWidth=10;</span><br>  <span>ctx.lineJoin=”miter”;</span><br>  <span>ctx.miterLimit=5;</span><br>  <span>ctx.moveTo(20,20);</span><br>  <span>ctx.lineTo(50,27);</span><br>  <span>ctx.lineTo(20,34);</span><br>  <span>ctx.stroke();</span><br></code></pre></blockquote><br><img src="http://oo6ltjdyl.bkt.clouddn.com/13456.png" alt=""><br>miterLimit 属性设置或返回最大斜接长度。<br>斜接长度指的是在两条线交汇处内角和外角之间的距离。<br><img src="http://oo6ltjdyl.bkt.clouddn.com/img_miterlimitFig.gif" alt=""><br>提示：只有当 lineJoin 属性为 “miter” 时，miterLimit 才有效。<br>边角的角度越小，斜接长度就会越大。<br>为了避免斜接长度过长，我们可以使用 miterLimit 属性。<br>如果斜接长度超过 miterLimit 的值，边角会以 lineJoin 的 “bevel” 类型来显示（Fig 3）<br><img src="http://oo6ltjdyl.bkt.clouddn.com/img_miterlimitBevelFig.gif" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/04/23/mls/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/23/mls/" itemprop="url">每一次的马拉松，只为更好的自己</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-23T00:00:00+08:00">
                2017-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/心情/" itemprop="url" rel="index">
                    <span itemprop="name">心情</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>人生就像是一场马拉松，陪你起点与陪你到终点的人总是不一样的。<br>在这场前进的路上，有人走得快点，有人走得慢点，有人急匆匆的只为了终点，有人不急不慢的欣赏着一路的风景。<br>说不清好与坏，随着自己的心就好。<br>我算不是上哪一种，不急着到终点，同时也无太多心思一路欣赏着风景，在自己规定的时间到目的地，每次进步一点点这场奔跑算得上有意义。<br><img src="http://oo6ltjdyl.bkt.clouddn.com/WechatIMG3.jpeg" alt=""><br>2017年4月23日7点东方明珠上海半程马拉松响枪开跑，不管经历了多少次马拉松，总在响枪和到达终点的那一刻，会莫名的兴奋。<br>跑上马的第三个年头，从最开始的8英里，到后面的半马。一路流过的汗，经历过多少次想放弃，只有自己明白。庆幸，最后都坚持下来了。<br>从最开始一群人的狂欢，到最后一个人的孤独。<br>因为走了一条少有人走的路，所以必须让自己拥有一颗坚固的心。<br>我的青春依旧还是不痛不痒。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/04/15/foreach/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/15/foreach/" itemprop="url">Array map()和forEach()方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-15T00:00:00+08:00">
                2017-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>共同点：<br>1.都是循环遍历数组中的每一项。<br>2.forEach() 和 map() 里面每一次执行匿名函数都支持3个参数：数组中的当前项item，当前项的索引index，原始数组input。<br>3.匿名函数中的this都是指Window。<br>4.只能遍历数组。</p>
<p></p><h2 style="font-size:16px;font-weight:bold;">map()：有返回值，可以return 出来。</h2><br>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。<br>map() 方法按照原始数组元素顺序依次处理元素。<br>注意： map() 不会对空数组进行检测。map() 不会改变原始数组。<p></p>
<p><blockquote><pre><code><span>arr[].map(function(value,index,array){</span><br>  <span>return xxx</span><br><span>})</span></code></pre></blockquote><br>参数：value数组中的当前项，index当前项的索引，array原始数组；<br>区别：map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）；</p>
<p></p><h2 style="font-size:16px;font-weight:bold;">forEach()：没有返回值。</h2><br>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。<br>注意: forEach() 对于空数组是不会执行回调函数的。<p></p>
<p><blockquote><pre><code><span>arr[].forEach(function(value,index,array){</span><br>  <span>//do something</span><br><span>})</span></code></pre></blockquote><br>参数：value数组中的当前项, index当前项的索引, array原始数组；<br>数组中有几项，那么传递进去的匿名回调函数就需要执行几次；<br>理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是可以自己通过数组的索引来修改原来的数组；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/03/17/high-order/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/17/high-order/" itemprop="url">React 高阶组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-17T00:00:00+08:00">
                2017-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>高阶组件就是一个 React 组件包裹着另外一个 React 组件。<br>高阶组件中所谓的包裹方式主要有以下两种：<br>1､ Props Proxy: 高阶组件通过WrappedComponent中的props来进行相关的操作。<br>2､ Inheritance Inversion: 高阶组件继承自WrappedComponent。</p>
<blockquote><pre><code><span>function ppHOC(WrappedComponent) {</span><br>  <span>return class PP extends React.Component {</span><br>    <span>render() {</span><br>      <span>return &lt;WrappedComponent {…this.props}/&gt;</span><br>    <span>}</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>这里主要是 HOC 在 render 方法中 返回 了一个 WrappedComponent 类型的 React Element。我们还传入了 HOC 接收到的 props，这就是名字 Props Proxy 的由来。<br><span style="font-size:18px;font-weight:bold;">高阶组件中的props、ref、state</span><br><span style="font-size:16px;font-weight:bold;">操作props</span><br>你可以在高阶组件中对ComponentClass中的props进行读取、添加、编辑操作。<br><blockquote><pre><code><span>function ppHOC(WrappedComponent) {</span><br>  <span>return class PP extends React.Component {</span><br>    <span>render() {</span><br>      <span>const newProps = {</span><br>        <span>name: “cqm”,</span><br>        <span>value: “testData”,</span><br>      <span>}</span><br>      <span>return &lt;WrappedComponent {…this.props} {…newProps}/&gt;</span><br>    <span>}</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>高阶组件中能够通过this.props直接获取到WrappedComponent中的props，假设this.props中有name，那么newProps中的name会覆盖掉this.props中的name。<br><span style="font-size:16px;font-weight:bold;">通过ref访问组件实例</span><br><blockquote><pre><code><span>function ppHOC(WrappedComponent) {</span><br>  <span>return class PP extends React.Component {</span><br>    <span>componentDidMount() {</span><br>      <span>console.log(this.refs.WrappedComponent);</span><br>    <span>}</span><br>    <span>render() {</span><br>      <span>return &lt;WrappedComponent ref=”WrappedComponent” /&gt;</span><br>    <span>}</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br><span style="font-size:16px;font-weight:bold;">获取state</span><br>你可以往ComponentClass中传入一个函数，之后ComponentClass中通过props拿到这个函数，往里面传入你想要的state参数。<br><blockquote><pre><code><span>function ppHOC(WrappedComponent) {</span><br>  <span>return class PP extends React.Component {</span><br>    <span>constructor(props) {</span><br>      <span>super(props)</span><br>        <span>this.state = { name: ‘’ }</span><br>        <span>this.onNameChange = this.onNameChange.bind(this)</span><br>      <span>}</span><br>      <span>onNameChange(event) {</span><br>        <span>this.setState({ name: event.target.value })</span><br>      <span>}</span><br>      <span>render() {</span><br>        <span>const newProps = {</span><br>          <span>name: {</span><br>            <span>value: this.state.name,</span><br>            <span>onChange: this.onNameChange</span><br>          <span>}</span><br>        <span>}</span><br>        <span>return <wrappedcomponent {...this.props}="" {...newprops}=""></wrappedcomponent></span><br>    <span>}</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br><blockquote><pre><code><span>class WrappedComponent extends React.Component {</span><br>  <span>render() {</span><br>    <span>return &lt;input name=”name” {…this.props.name}/&gt;</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/03/03/react-redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/03/react-redux/" itemprop="url">react 和 redux 的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-03T00:00:00+08:00">
                2017-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redux 默认并不包含 React 绑定库，需要单独安装。</p>
<blockquote><pre><code><span>npm install –save react-redux</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">容器组件（Container）和展示组件（Components）</span><br>Redux 的 React 绑定库包含了 容器组件和展示组件相分离 的开发思想。<br>明智的做法是只在最顶层组件（如路由操作）里使用 Redux。其余内部组件仅仅是展示性的，所有数据都通过 props 传入。<br>component只关注展示层。container是通过connect方法把redux和展示组件关联起来的东西。<br><img src="http://oo6ltjdyl.bkt.clouddn.com/A93C65181AE8.png" alt=""><br>UI 组件有以下几个特征。<br>（1）只负责 UI 的呈现，不带有任何业务逻辑<br>（2）没有状态（即不使用this.state这个变量）<br>（3）所有数据都由参数（this.props）提供<br>（4）不使用任何 Redux 的 API<br>容器组件的特征恰恰相反。<br>（1）负责管理数据和业务逻辑，不负责 UI 的呈现<br>（2）带有内部状态<br>（3）使用 Redux 的 API<br>只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。<br><span style="font-size:18px;font-weight:bold;">connect([mapStateToProps], [mapDispatchToProps], [mergeProps] )</span><br>connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。<br>接 React 组件与 Redux store。连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。<br>（1）输入逻辑：外部的数据（即state对象）如何转换为 UI 组件的参数<br>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。<br><blockquote><pre><code><span>import { connect } from ‘react-redux’</span><br><span>const VisibleTodoList = connect(</span><br>  <span>mapStateToProps,</span><br>  <span>mapDispatchToProps</span><br><span>)(TodoList)</span></code></pre></blockquote><br>上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。<br>1)[mapStateToProps(state, [ownProps]): stateProps] (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 ownProps，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，mapStateToProps 也会被调用。<br>2)[mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，而且这个对象会与 Redux store 绑定在一起，其中所定义的方法名将作为属性名，合并到组件的 props 中。如果传递的是一个函数，该函数将接收一个 dispatch 函数，然后由你来决定如何返回一个对象，这个对象通过 dispatch 函数与 action creator 以某种方式绑定在一起（提示：你也许会用到 Redux 的辅助函数 bindActionCreators()）。如果你省略这个 mapDispatchToProps 参数，默认情况下，dispatch 会注入到你的组件 props 中。如果指定了该回调函数中第二个参数 ownProps，该参数的值为传递到组件的 props，而且只要组件接收到新 props，mapDispatchToProps 也会被调用。<br>3)[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。你也许可以用这个回调函数，根据组件的 props 来筛选部分的 state 数据，或者把 props 中的某个特定变量与 action creator 绑定在一起。如果你省略这个参数，默认情况下返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。<br><span style="font-size:18px;font-weight:bold;">Provider</span><br><provider store=""> 使组件层级中的 connect() 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <provider> 中才能使用 connect() 方法。<br>如果你真的不想把根组件嵌套在 <provider> 中，你可以把 store 作为 props 传递到每一个被 connet() 包装的组件，但是我们只推荐您在单元测试中对 store 进行伪造 (stub) 或者在非完全基于 React 的代码中才这样做。正常情况下，你应该使用 <provider>。<br>1)store (Redux Store): 应用程序中唯一的 Redux store 对象<br>2)children (ReactElement) 组件层级的根组件。<br><blockquote><pre><code><span>ReactDOM.render(</span><br>  <span>&lt;Provider store={store}&gt;</span><br>  <span><myrootcomponent &gt;<="" span=""><br>  <span>&lt;/Provider&gt;,</span><br>  <span>rootEl</span><br><span>);</span></myrootcomponent></span></code></pre></blockquote></provider></provider></provider></provider>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/02/17/middleware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/17/middleware/" itemprop="url">Redux 中间件和异步操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-17T00:00:00+08:00">
                2017-02-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redux/" itemprop="url" rel="index">
                    <span itemprop="name">Redux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。<br>（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。<br>（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。<br>中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。<br><span style="font-size:18px;font-weight:bold;">applyMiddleware()</span><br>在 dispatch 机制中引入 Redux Thunk middleware，我们使用了 applyMiddleware()。</p>
<p><blockquote><pre><code><span>const store = createStore(</span><br>  <span>reducers</span><br>  <span>applyMiddleware(</span><br>    <span>thunkMiddleware, // 允许我们 dispatch() 函数</span><br>    <span>loggerMiddleware // 一个很便捷的 middleware，用来打印 action 日志</span><br>  <span>)</span><br><span>)</span></code></pre></blockquote><br>applyMiddleware 它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。<br>最常见的使用场景是无需引用大量代码或依赖类似 Rx 的第三方库实现异步 actions。可以让你像 dispatch 一般的 actions 那样 dispatch 异步 actions。<br><span style="font-size:18px;font-weight:bold;">redux-thunk 中间件</span><br>store.dispatch方法正常情况下，参数只能是对象，不能是函数。这时，就要使用中间件redux-thunk。</p>
<p><blockquote><pre><code><span>export function fetchPosts(subreddit) {</span><br>  <span>// Thunk middleware 知道如何处理函数。</span><br>  <span>// 这里把 dispatch 方法通过参数的形式传给函数，</span><br>  <span>// 以此来让它自己也能 dispatch action。</span><br>  <span>return function (dispatch) {</span><br>    <span>// 首次 dispatch：更新应用的 state 来通知</span><br>    <span>// API 请求发起了。</span><br>    <span>dispatch(requestPosts(subreddit))</span><br>    <span>// thunk middleware 调用的函数可以有返回值，</span><br>    <span>// 它会被当作 dispatch 方法的返回值传递。</span><br>    <span>// 这个案例中，我们返回一个等待处理的 promise。</span><br>    <span>// 这并不是 redux middleware 所必须的，但这对于我们而言很方便。</span><br>    <span>return fetch(<code>http://www.subreddit.com/r/${subreddit}.json</code>)</span><br>    <span>.then(response =&gt; response.json())</span><br>    <span>.then(json =&gt;</span><br>      <span>// 可以多次 dispatch！</span><br>      <span>// 这里，使用 API 请求结果来更新应用的 state。</span><br>      <span>dispatch(receivePosts(subreddit, json))</span><br>    <span>)</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>（1）fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。<br>（2）返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。<br>（3）在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始。<br>（4）异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/02/10/redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/10/redux/" itemprop="url">初识Redux</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-10T00:00:00+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redux/" itemprop="url" rel="index">
                    <span itemprop="name">Redux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redux 通过一个 JavaScript 对象管理状态，该对象称为数据存储，包含应用程序的所有状态。将状态集中保存在一个对象中，这使得在阅读代码时推断应用程序数据变得更容易。<br>Redux基本原则<br>1)单一数据源：应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。<br>2)State 是只读的：惟一改变 state 的办法是触发 action，一个描述发生什么的对象。<br>3)使用纯函数来执行修改：为了描述 action 如何改变 state 树，你需要编写 reducers。<br>Redux的设计思想：<br>1)Web 应用是一个状态机，视图与状态是一一对应。<br>2)所有的状态，保存在一个对象里。<br><span style="font-size:18px;font-weight:bold;">state</span><br>就是app中数据组成的树，也是一个普通的js对象。树的结构根据应用的需要自行决定，官方推荐的方式是分为三种数据：<br>1)后端提供的应用数据<br>2)应用状态数据 （某条数据是否选中）<br>3)ui组件的数据（弹窗是否打开）<br><span style="font-size:18px;font-weight:bold;">actions</span><br>action 来描述“发生了什么”。<br>把数据从应用传到store的有效载荷。它是store数据的唯一来源。Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。除了 type 字段外，action 对象的结构完全由你自己决定。我们应该尽量减少在 action 中传递的数据。</p>
<p><blockquote><pre><code><span>{</span><br>  <span>type: ‘ADD_NEWS’,</span><br>  <span>text: ‘这是一条新闻’</span><br><span>}</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">action 创建函数</span><br>action 创建函数 就是生成 action 的方法。</p>
<p><blockquote><pre><code><span>function addNews(text) {</span><br>  <span>return {</span><br>    <span>type: ADD_NEWS,</span><br>    <span>text</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。</p>
<p><blockquote><pre><code><span>dispatch(addNews(text))</span></code></pre></blockquote><br><span style="font-size:18px;font-weight:bold;">reducer</span><br>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。<br>reducer 一定要保持纯净。只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。<br>永远不要在 reducer 里做这些操作：<br>1)修改传入参数；<br>2)执行有副作用的操作，如 API 请求和路由跳转；<br>3)调用非纯函数，如 Date.now() 或 Math.random()。</p>
<p><blockquote><pre><code><span>function newsReducer(state = initialState, action) {</span><br>  <span>switch (action) {</span><br>    <span>case: ‘ADD_NEWS’:</span><br>      <span>return […state, text]</span><br>      <span>break;</span><br>    <span>default:</span><br>      <span>return state;</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>实际应用中，Reducer 函数不用像手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</p>
<p><blockquote><pre><code><span>import { createStore } from ‘redux’;</span><br><span>const store = createStore(reducer);</span></code></pre></blockquote><br>上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。<br><span style="font-size:18px;font-weight:bold;">combineReducers</span><br>combineReducers辅助函数的作用是，把一个由多个不同的reducer函数作为value的object，合并成一个最终的reducer函数，然后就可以对这个reducer调用createStore。<br>通过为传入对象的 reducer 命名不同来控制 state key 的命名。ES6 的简写方法：combineReducers({ counter, todos })。<br><span style="font-size:18px;font-weight:bold;">store</span><br>store 就是把它们联系到一起的对象。<br>1)维持应用的 state；<br>2)提供 getState() 方法获取 state；<br>3)提供 dispatch(action) 方法更新 state；<br>4)通过 subscribe(listener) 注册监听器;<br>5)通过 subscribe(listener) 返回的函数注销监听器。<br>Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。</p>
<p><blockquote><pre><code><span>let store = createStore(todoApp, window.STATE_FROM_SERVER)</span></code></pre></blockquote><br>createStore() 的第二个参数是可选的, 用于设置 state 初始状态。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2017/01/06/webpack-react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/06/webpack-react/" itemprop="url">webpack与react的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-06T00:00:00+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接着上篇文章我们来看看webpack与react的应用，那么就不得不说Loaders了。<br>通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。而对react而言，可以把React的JSX文件转换为JS文件。<br>Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面：</p>
<blockquote><pre><code><span>test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）；</span><br><span>loader：loader的名称（必须）；</span><br><span>include/exclude: 手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</span><br><span>query：为loaders提供额外的设置选项（可选）。</span></code></pre></blockquote><br>Loaders很好，不过有的Loaders使用起来比较复杂，比如说Babel。<br>Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的：<br>1､ 下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持；<br>2､ 使用基于JavaScript进行了拓展的语言，比如React的JSX。<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。<br><blockquote><pre><code><span>// npm一次性安装多个依赖模块，模块之间用空格隔开</span><br><span>npm install –save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</span></code></pre></blockquote><br>使用ES6以及JSX的语法，安装 React 和 React-DOM：<br><blockquote><pre><code><span>npm install –save react react-dom</span></code></pre></blockquote><br>在webpack中配置Babel的方法如下：<br><blockquote><pre><code><span>module.exports = {</span><br>  <span>entry: &#95;&#95;dirname + “/app/main.js”, </span><br>  <span>output: {</span><br>    <span>path: &#95;&#95;dirname + “/public”,</span><br>    <span>filename: “bundle.js”</span><br>  <span>},</span><br>  <span>module: {</span><br>    <span>loaders: [</span><br>      <span>{</span><br>        <span>test: /.js$/,</span><br>        <span>exclude: /node_modules/,</span><br>        <span>loader: ‘babel-loader’,//在webpack的module部分的loaders里进行配置即可</span><br>        <span>query: {</span><br>          <span>presets: [‘es2015’,’react’]</span><br>        <span>}</span><br>      <span>},</span><br>    <span>]</span><br>  <span>},</span><br>  <span>devServer: {</span><br>    <span>contentBase: &#95;&#95;dirname + “/public”,</span><br>    <span>historyApiFallback: true,</span><br>    <span>inline: true</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>更新Greeter.js并返回一个React组件<br><blockquote><pre><code><span>//Greeter,js</span><br><span>import React, {Component} from ‘react’</span><br><span>class Greeter extends Component{</span><br>  <span>render() {</span><br>    <span>return (</span><br>      <span>&lt;div&gt;</span><br>        <span>&lt;span&gt;</span><span>Hi there and greetings from JSON!</span><span>&lt;/span&gt;</span><br>      <span>&lt;/div&gt;</span><br>    <span>);</span><br>  <span>}</span><br><span>}</span><br><span>export default Greeter</span></code></pre></blockquote><br>使用ES6的模块定义和渲染Greeter模块<br><blockquote><pre><code><span>//main.js</span><br><span>import React from ‘react’;</span><br><span>import {render} from ‘react-dom’;</span><br><span>import Greeter from ‘./Greeter’;</span><br><span>render(<greeter>, document.getElementById(‘root’));</greeter></span></code></pre></blockquote><br>webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。对CSS模块化提供了支持，在CSS loader中进行配置。<br><blockquote><pre><code>npm install –save-dev style-loader css-loader</code></pre></blockquote><br><blockquote><pre><code><span>module: {</span><br>  <span>loaders: [</span><br>    <span>{</span><br>      <span>test: /.js$/,</span><br>      <span>exclude: /node_modules/,</span><br>      <span>loader: ‘babel-loader’,//在webpack的module部分的loaders里进行配置即可</span><br>      <span>query: {</span><br>        <span>presets: [‘es2015’,’react’]</span><br>      <span>}</span><br>    <span>},</span><br>    <span>{</span><br>      <span>test: /.css$/,</span><br>      <span>exclude: /node_modules/,</span><br>      <span>loader: ‘style-loader!css-loader’ //添加对样式表的处理</span><br>    <span>},</span><br>  <span>]</span><br><span>},</span></code></pre></blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http:socat.cc/2016/12/23/webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="socat">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="socat">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/23/webpack/" itemprop="url">webpack的开始与使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-23T00:00:00+08:00">
                2016-12-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Webpack/" itemprop="url" rel="index">
                    <span itemprop="name">Webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>webpack 是一个用来构建我们应用程序中的JavaScript模块的工具。webpack 通过快速建立应用程序依赖图表并以正确的顺序打包它们来简化你的工作流。你能够针对你的代码来对 webpack 进行自定义的优化配置。<br>webpack 是一个现代的 JavaScript 应用程序的模块打包器(module bundler)。它是高度可配置的，但是，在开始前你需要先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。</p>
<p><blockquote><pre><code><span>//一个常见的webpack配置文件</span><br><span>module.exports = {</span><br>  <span>entry: &#95;&#95;dirname + “/app/main.js”, </span><br>  <span>output: {</span><br>    <span>path: &#95;&#95;dirname + “/public”,</span><br>    <span>filename: “bundle.js”</span><br>  <span>},</span><br>  <span>module: {</span><br>    <span>loaders: [</span><br>      <span>{</span><br>        <span>test: /.css$/,</span><br>        <span>loader: “css-loader”</span><br>      <span>},</span><br>    <span>]</span><br>  <span>},</span><br>  <span>plugins: [</span><br>    <span>new webpack.BannerPlugin(“Copyright Flying Unicorns inc.”)//在这个数组中new一个就可以了</span><br>  <span>],</span><br>  <span>devServer: {</span><br>    <span>contentBase: &#95;&#95;dirname + “/public”,</span><br>    <span>historyApiFallback: true,</span><br>    <span>inline: true</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>入口(Entry)：入口起点告诉 webpack 从哪里开始，并遵循着依赖关系图表知道要打包什么。可以将您应用程序的入口起点认为是根上下文(contextual root)或 app 第一个启动文件。<br>出口(Output)：将所有的资源(assets)归拢在一起后，还需要告诉 webpack 在哪里打包应用程序。我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要生成(emit)到哪里。<br>加载器(Loaders)：webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中。对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这可以告诉 webpack compiler 如下：</p>
<p><blockquote><pre><code><span>“嘿，webpack compiler，当你碰到「在 require()/import 语句中被解析为 ‘.js’ 或 ‘.jsx’ 的路径」时，</span><br><span>在你把它们添加并打包之前，要先使用 babel-loader 去转换”。</span><br><span style="color:red">webpack最新版本 module:{ loaders:[ test:/.json$/,loader: ‘json’] } </span><br><span style="color:red">loader一定要加上”-loader”，否则会报错。</span></code></pre></blockquote><br>插件(Plugins)：由于 loader 仅在每个文件的基础上执行转换，而 插件(plugins)最常用于（但不限于）在打包模块的“compilation”和“chunk”生命周期执行操作和自定义功能（查看更多）。webpack 的插件系统极其强大和可定制化。<br>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，你需要使用 new 创建实例来调用它。<br><span style="font-size:16px;font-weight:bold;">开始使用Webpack</span><br>1､webpack基于node和npm安装，node、npm请先安装好。<br>2､新建文件夹（webpack project）<br>3､创建一个package.json文件</p>
<p><blockquote><pre><code><span>npm init // npm init命令可以自动创建这个package.json文件</span></code></pre></blockquote><br>4､安装Webpack作为依赖包 </p>
<p><blockquote><pre><code><span>npm install -g webpack //全局安装</span><br><span>npm install –save-dev webpack //安装到你的项目目录</span></code></pre></blockquote><br>5､回到webpack project文件夹，新建app与public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。<br><img src="http://oo6ltjdyl.bkt.clouddn.com/files.jpg" alt=""><br>index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js）</p>
<p><blockquote><pre><code><span>&lt;!DOCTYPE html&gt;</span><br><span>&lt;html lang=”en”&gt;</span><br>  <span>&lt;head&gt;</span><br>    <span>&lt;title&gt;</span><span>Webpack</span><span>&lt;/title&gt;</span><br>  <span>&lt;/head&gt;</span><br>  <span>&lt;body&gt;</span><br>    <span>&lt;div id=’root’&gt;</span><span>&lt;/div&gt;</span><br>    <span>&lt;script src=”bundle.js”&gt;</span><span>&lt;/script&gt;</span><br>  <span>&lt;/body&gt;</span><br><span>&lt;/html&gt;</span></code></pre></blockquote><br>Greeter.js只包括一个用来返回包含问候信息的html元素的函数。</p>
<p><blockquote><pre><code><span>// Greeter.js</span><br><span>module.exports = function() {</span><br>  <span>var greet = document.createElement(‘div’);</span><br>  <span>greet.textContent = “Hi there and greetings!”;</span><br>  <span>return greet;</span><br><span>};</span></code></pre></blockquote><br>main.js用来把Greeter模块返回的节点插入页面。</p>
<p><blockquote><pre><code><span>//main.js </span><br><span>var greeter = require(‘./Greeter.js’);</span><br><span>document.getElementById(‘root’).appendChild(greeter());</span><br></code></pre></blockquote><br>在根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，它包含入口文件路径和存放打包后文件的地方的路径。</p>
<p><blockquote><pre><code><span>module.exports = {</span><br>  <span>entry:  &#95;&#95;dirname + “/app/main.js”, //唯一入口文件</span><br>  <span>output: {</span><br>    <span>path: &#95;&#95;dirname + “/public”, //打包后的文件存放的地方</span><br>    <span>filename: “bundle.js”//打包后输出文件的文件名</span><br>  <span>}</span><br><span>}</span><br><span>注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</span></code></pre></blockquote><br>现在如果你需要打包文件只需要在终端里你运行webpack命令就可以了，现在打开index.html,可以结果。<br><span style="font-size:16px;font-weight: bold;">使用webpack构建本地服务器</span><br>让你的浏览器监测你的代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖。</p>
<p><blockquote><pre><code><span>npm install –save-dev webpack-dev-server</span></code></pre></blockquote><br>devserver作为webpack配置选项中的一项，具有以下配置选项<br><img src="http://oo6ltjdyl.bkt.clouddn.com/table.jpg" alt=""><br>配置文件更新:</p>
<p><blockquote><pre><code><span>module.exports = {</span><br>  <span>entry: &#95;&#95;dirname + “/app/main.js”,</span><br>  <span>output: {</span><br>    <span>path: &#95;&#95;dirname + “/public”,</span><br>    <span>filename: “bundle.js” </span><br>  <span>},</span><br>  <span>devServer: {</span><br>    <span>contentBase: &#95;&#95;dirname + “/public”,</span><br>    <span>historyApiFallback: true,</span><br>    <span>inline: true</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可。</p>
<p><blockquote><pre><code><span>//package.json</span><br><span>{</span><br>  <span>“name”: “webpack project”,</span><br>  <span>“version”: “1.0.0”,</span><br>  <span>“description”: “”,</span><br>  <span>“scripts”: {</span><br>    <span>“start”: “webpack-dev-server –hot –inline”</span><br>  <span>},</span><br>  <span>“author”: “”,</span><br>  <span>“license”: “ISC”,</span><br>  <span>“devDependencies”: {</span><br>    <span>“webpack”: “^2.4.1”,</span><br>    <span>“webpack-dev-server”: “^2.4.2”</span><br>  <span>}</span><br><span>}</span></code></pre></blockquote><br>在命令行中使用npm start就可以执行相关命令，在浏览器里面输入<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> ，在js里面随便修改一些输出然后保存, 浏览器自动刷新，新的结果出现了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="socat" />
          <p class="site-author-name" itemprop="name">socat</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">socat</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
